# -*- coding: utf-8 -*-
"""RailwaysUKipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IhGSNSH6S6NHo6RRRFBxMS58z_-C0J2U

#**Data Analysis Railway in UK**
#**Part 1**
#**Toolkit & Loading Data and Inspecting**

#**Toolkit**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""#**Loading Data and Inspecting**"""

df = pd.read_csv('/content/railway.csv')

df.head()

df.info()

df.describe().round(4)

pip install ydata-profiling

from ydata_profiling import ProfileReport
ProfileReport(df)

"""#**Part 2**
#**Data Cleaning and Preparation**

#**Handle missing values**
"""

df.isnull().sum()

total_rows = len(df)

missing_railcard = df['Railcard'].isnull().sum()
missing_actual_arrival_time = df['Actual Arrival Time'].isnull().sum()
missing_reason_for_delay = df['Reason for Delay'].isnull().sum()

print(f"Missing values in 'Railcard': {missing_railcard} ({missing_railcard / total_rows:.2%})")
print(f"Missing values in 'Actual Arrival Time': {missing_actual_arrival_time} ({missing_actual_arrival_time / total_rows:.2%})")
print(f"Missing values in 'Reason for Delay': {missing_reason_for_delay} ({missing_reason_for_delay / total_rows:.2%})")

df['Railcard'] = df['Railcard'].fillna('Unknown')
df['Reason for Delay'] = df['Reason for Delay'].fillna('Unknown Reason')
on_time_mask = df['Journey Status'] == 'On Time'
df.loc[on_time_mask, 'Actual Arrival Time'] = df.loc[on_time_mask, 'Actual Arrival Time'].fillna(df.loc[on_time_mask, 'Arrival Time'])

# Remove trailing space from 'Adult ' in 'Railcard' column
df['Railcard'] = df['Railcard'].replace('Adult ', 'Adult')

print("Percentage of missing values after handling:")
print(df.isnull().mean() * 100)

df['Actual Arrival Time'].fillna(df['Arrival Time'])
print(f"Missing values in 'Actual Arrival Time' after handling: {df['Actual Arrival Time'].isnull().sum()}")

print(df.isnull().mean() * 100)

"""#**Handle duplicates**"""

df.duplicated().sum()

"""#**Data Transformation**"""

df['Date of Purchase'] = pd.to_datetime(df['Date of Purchase'])
df['Date of Journey'] = pd.to_datetime(df['Date of Journey'])

df['Time of Purchase'] = pd.to_datetime(df['Time of Purchase'], format='%H:%M:%S')
df['Departure Time'] = pd.to_datetime(df['Departure Time'], format='%H:%M:%S')
df['Arrival Time'] = pd.to_datetime(df['Arrival Time'], format='%H:%M:%S')
df['Actual Arrival Time'] = pd.to_datetime(df['Actual Arrival Time'], format='%H:%M:%S', errors='coerce')

df.info()

"""#**Calculate journey duration and delay and convert categorical columns to category data type.**"""

df['Departure_datetime'] = pd.to_datetime(df['Date of Journey'].astype(str) + ' ' + df['Departure Time'].astype(str))
df['Scheduled_Arrival_datetime'] = pd.to_datetime(df['Date of Journey'].astype(str) + ' ' + df['Arrival Time'].astype(str))

# Handle potential NaT values in 'Actual Arrival Time' before combining with 'Date of Journey'
df['Actual_Arrival_datetime'] = pd.to_datetime(df['Date of Journey'].astype(str) + ' ' + df['Actual Arrival Time'].astype(str), errors='coerce')

df['Journey Duration'] = (df['Actual_Arrival_datetime'] - df['Departure_datetime']).dt.total_seconds() / 60
df.loc[df['Journey Duration'] < 0, 'Journey Duration'] += 24 * 60  # Add 24 hours if negative

df['Delay'] = (df['Scheduled_Arrival_datetime'] - df['Actual_Arrival_datetime']).dt.total_seconds() / 60

categorical_cols = ['Purchase Type', 'Payment Method', 'Railcard', 'Ticket Class', 'Ticket Type', 'Departure Station', 'Arrival Destination', 'Journey Status', 'Refund Request']
for col in categorical_cols:
    df[col] = df[col].astype('category')

df = df.drop(columns=['Departure_datetime', 'Actual_Arrival_datetime', 'Scheduled_Arrival_datetime'])

"""#**Handle potential inconsistencies in categorical data**"""

categorical_cols = ['Purchase Type', 'Payment Method', 'Railcard', 'Ticket Class', 'Ticket Type', 'Departure Station', 'Arrival Destination', 'Journey Status', 'Reason for Delay', 'Refund Request']
for col in categorical_cols:
    encoded_cols = [c for c in df.columns if c.startswith(col + '_')]
    print(f"Unique values for one-hot encoded '{col}' columns:")
    for encoded_col in encoded_cols:
        print(f"- {encoded_col}: {df[encoded_col].unique()}")

"""**Based on the previous output, there are inconsistencies in the 'Reason for Delay' column with both 'Signal Failure' and 'Signal failure', and 'Staff Shortage' and 'Staffing', and 'Weather' and 'Weather Conditions'. These need to be unified by renaming the one-hot encoded columns and then combining them.**"""

# Perform one-hot encoding on the 'Reason for Delay' column
df = pd.get_dummies(df, columns=['Reason for Delay'], prefix='Reason for Delay')

# Now combine the columns with similar meanings
df['Reason for Delay_Signal Failure'] = df['Reason for Delay_Signal Failure'] | df['Reason for Delay_Signal failure']
df.drop(columns=['Reason for Delay_Signal failure'], inplace=True)
df['Reason for Delay_Staff Shortage'] = df['Reason for Delay_Staff Shortage'] | df['Reason for Delay_Staffing']
df.drop(columns=['Reason for Delay_Staffing'], inplace=True)
df['Reason for Delay_Weather'] = df['Reason for Delay_Weather'] | df['Reason for Delay_Weather Conditions']
df.drop(columns=['Reason for Delay_Weather Conditions'], inplace=True)

# Display the updated columns
display(df[['Reason for Delay_Signal Failure', 'Reason for Delay_Staff Shortage', 'Reason for Delay_Weather']].head())

"""#**Part 3**
#**Basic Analysis (Distribution , Outliers , Winsorizing)**

#**Price Distribution**
"""

plt.figure(figsize=(10, 6))
sns.histplot(df['Price'], kde=True)
plt.title('Distribution of Price')
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.show()

"""#**Price Distribution (Outliers)**"""

plt.figure(figsize=(10, 6))
sns.boxplot(x=df['Price'])
plt.title('Box Plot of Price to Identify Outliers')
plt.xlabel('Price')
plt.show()

"""#**Explore Outliers in Price**"""

# Sort the DataFrame by 'Price' in descending order and display the top N rows
n_top_outliers = 10  # You can adjust this number
df_sorted_by_price = df.sort_values(by='Price', ascending=False)
display(df_sorted_by_price.head(n_top_outliers))

"""#**Define a threshold for high prices:**

**Calculate Q1, Q3, and IQR for the 'Price' column, define the upper bound for outliers, and use it as the threshold for high prices.**
"""

Q1 = df['Price'].quantile(0.25)
Q3 = df['Price'].quantile(0.75)
IQR = Q3 - Q1
upper_bound = Q3 + 1.5 * IQR
print(f"Q1: {Q1}")
print(f"Q3: {Q3}")
print(f"IQR: {IQR}")
print(f"Upper bound (High Price Threshold): {upper_bound}")

"""#Create a subset of high-priced tickets

**Filter the DataFrame to create a new DataFrame containing only the rows where the 'Price' is above the defined threshold.**
"""

df_high_price = df[df['Price'] > upper_bound].copy()
display(df_high_price.head())
print(f"Number of high-priced tickets: {len(df_high_price)}")

"""#**Compare characteristics**

**Create a subset for non-high-priced tickets, calculate and print descriptive statistics for numerical columns, and calculate and print value counts for categorical columns for both subsets.**
"""

df_not_high_price = df[df['Price'] <= upper_bound].copy()
numerical_cols_compare = ['Journey Duration', 'Delay']
print("Descriptive statistics for High-Priced Tickets:")
display(df_high_price[numerical_cols_compare].describe())
print("\nDescriptive statistics for Not High-Priced Tickets:")
display(df_not_high_price[numerical_cols_compare].describe())
categorical_cols_compare = ['Purchase Type', 'Payment Method', 'Railcard', 'Ticket Class', 'Ticket Type', 'Departure Station', 'Arrival Destination', 'Journey Status', 'Reason for Delay_Signal Failure', 'Reason for Delay_Staff Shortage', 'Reason for Delay_Technical Issue', 'Reason for Delay_Traffic', 'Reason for Delay_Unknown Reason', 'Reason for Delay_Weather', 'Refund Request']
print("\nValue counts for Categorical Columns (High-Priced Tickets):")
for col in categorical_cols_compare:
    print(f"\n{col}:")
    display(df_high_price[col].value_counts(normalize=True))
print("\nValue counts for Categorical Columns (Not High-Priced Tickets):")
for col in categorical_cols_compare:
    print(f"\n{col}:")
    display(df_not_high_price[col].value_counts(normalize=True))

"""**Visualize the distribution of key numerical and categorical columns for both high-priced and not high-priced tickets to compare their characteristics.**"""

numerical_cols_to_plot = ['Journey Duration', 'Delay']
for col in numerical_cols_to_plot:
    plt.figure(figsize=(12, 6))
    sns.histplot(df_high_price[col], kde=True, color='skyblue', label='High Price')
    sns.histplot(df_not_high_price[col], kde=True, color='salmon', label='Not High Price')
    plt.title(f'Distribution of {col} by Price Category')
    plt.xlabel(col)
    plt.ylabel('Frequency')
    plt.legend()
    plt.show()

# Perform one-hot encoding on the categorical columns to be plotted
categorical_cols_to_encode = ['Purchase Type', 'Ticket Class', 'Ticket Type', 'Journey Status', 'Refund Request']
df_high_price_encoded = pd.get_dummies(df_high_price, columns=categorical_cols_to_encode, drop_first=False)
df_not_high_price_encoded = pd.get_dummies(df_not_high_price, columns=categorical_cols_to_encode, drop_first=False)

categorical_cols_to_plot = ['Purchase Type_Station', 'Ticket Class_Standard', 'Ticket Type_Anytime', 'Ticket Type_Off-Peak', 'Journey Status_On Time', 'Refund Request_Yes']
for col in categorical_cols_to_plot:
    plt.figure(figsize=(8, 5))
    high_price_counts = df_high_price_encoded[col].value_counts(normalize=True).reset_index()
    high_price_counts['Price Category'] = 'High Price'
    not_high_price_counts = df_not_high_price_encoded[col].value_counts(normalize=True).reset_index()
    not_high_price_counts['Price Category'] = 'Not High Price'
    combined_counts = pd.concat([high_price_counts, not_high_price_counts])
    sns.barplot(x=col, y='proportion', hue='Price Category', data=combined_counts)
    plt.title(f'Proportion of {col} by Price Category')
    plt.xlabel(col)
    plt.ylabel('Proportion')
    plt.show()

"""#**Apply Winsorizing to the 'Price' column to cap outlier values at specified percentiles.**

**Calculate the lower and upper bounds for Winsorizing based on percentiles (e.g., 5th and 95th) and apply the capping to the 'Price' column. Display the descriptive statistics and a box plot after Winsorizing to verify the effect.**
"""

# Calculate lower and upper bounds based on percentiles
lower_bound = df['Price'].quantile(0.05)
upper_bound_winsorize = df['Price'].quantile(0.95)
# Apply Winsorizing
df['Price_winsorized'] = df['Price'].clip(lower=lower_bound, upper=upper_bound_winsorize)
# Display descriptive statistics of the new column
print("Descriptive statistics of 'Price' after Winsorizing:")
display(df['Price_winsorized'].describe())
# Display a box plot of the new column to visualize the effect
plt.figure(figsize=(10, 6))
sns.boxplot(x=df['Price_winsorized'])
plt.title('Box Plot of Price after Winsorizing')
plt.xlabel('Price (Winsorized)')
plt.show()

"""#**Part 4**
#**KPIs**

# **Key Performance Indicators: Revenue/Prices and Routes**
"""

# Display previously calculated KPIs for Revenue/Prices
print("Total Revenue:")
total_revenue = df['Price'].sum()
print(f"{total_revenue}")

print("\nAverage Ticket Price:")
average_price = df['Price'].mean()
print(f"{average_price:.2f}")

"""## Revenue by Stations"""

# Calculate total revenue per departure station
revenue_by_departure_station = df.groupby('Departure Station')['Price'].sum().sort_values(ascending=False)
print("Total Revenue by Departure Station:")
display(revenue_by_departure_station)

# Calculate total revenue per arrival station
revenue_by_arrival_station = df.groupby('Arrival Destination')['Price'].sum().sort_values(ascending=False)
print("\nTotal Revenue by Arrival Station:")
display(revenue_by_arrival_station)

"""## Revenue by Ticket Type and Class"""

# Calculate total revenue by Ticket Type
revenue_by_ticket_type = df.groupby('Ticket Type')['Price'].sum().sort_values(ascending=False)
print("Total Revenue by Ticket Type:")
display(revenue_by_ticket_type)

# Calculate total revenue by Ticket Class
revenue_by_ticket_class = df.groupby('Ticket Class')['Price'].sum().sort_values(ascending=False)
print("\nTotal Revenue by Ticket Class:")
display(revenue_by_ticket_class)

# Calculate total revenue by Ticket Type and Ticket Class
revenue_by_type_and_class = df.groupby(['Ticket Type', 'Ticket Class'])['Price'].sum().unstack(fill_value=0)
print("\nTotal Revenue by Ticket Type and Ticket Class:")
display(revenue_by_type_and_class)

"""## Revenue per Journey"""

# Calculate average revenue per journey (which is the average ticket price)
average_revenue_per_journey = df['Price'].mean()
print(f"Average Revenue per Journey: {average_revenue_per_journey:.2f}")

"""# **Key Performance Indicators: Time and Delay**"""

# Calculate average delay
average_delay = df['Delay'].mean()
print(f"Average Delay (minutes): {average_delay:.2f}")

# Calculate proportion of delayed journeys
delayed_journeys_count = df[df['Journey Status'] == 'Delayed'].shape[0]
total_journeys_count = df.shape[0]
proportion_delayed = delayed_journeys_count / total_journeys_count
print(f"Proportion of Delayed Journeys: {proportion_delayed:.2%}")

# Calculate average delay for delayed journeys
average_delay_for_delayed = df[df['Journey Status'] == 'Delayed']['Delay'].mean()
print(f"Average Delay for Delayed Journeys Only (minutes): {average_delay_for_delayed:.2f}")

"""# **Key Performance Indicators: Ticket Types and Purchase Methods**"""

# Calculate proportion of each Ticket Type
print("\nProportion of each Ticket Type:")
display(df['Ticket Type'].value_counts(normalize=True))

# Calculate proportion of each Purchase Type
print("\nProportion of each Purchase Type:")
display(df['Purchase Type'].value_counts(normalize=True))

# Calculate proportion of each Payment Method
print("\nProportion of each Payment Method:")
display(df['Payment Method'].value_counts(normalize=True))

"""#**Part 5**
#**Deep analysis**

**Analyze the distribution of the price column**
"""

df_not_high_price = df[df['Price'] <= upper_bound].copy()

numerical_cols_compare = ['Journey Duration', 'Delay']
print("Descriptive statistics for High-Priced Tickets:")
display(df_high_price[numerical_cols_compare].describe())
print("\nDescriptive statistics for Not High-Priced Tickets:")
display(df_not_high_price[numerical_cols_compare].describe())

categorical_cols_compare = ['Purchase Type', 'Payment Method', 'Railcard', 'Ticket Class', 'Ticket Type', 'Departure Station', 'Arrival Destination', 'Journey Status', 'Reason for Delay_Signal Failure', 'Reason for Delay_Staff Shortage', 'Reason for Delay_Technical Issue', 'Reason for Delay_Traffic', 'Reason for Delay_Unknown Reason', 'Reason for Delay_Weather', 'Refund Request']
print("\nValue counts for Categorical Columns (High-Priced Tickets):")
for col in categorical_cols_compare:
    print(f"\n{col}:")
    display(df_high_price[col].value_counts(normalize=True))

print("\nValue counts for Categorical Columns (Not High-Priced Tickets):")
for col in categorical_cols_compare:
    print(f"\n{col}:")
    display(df_not_high_price[col].value_counts(normalize=True))

numerical_cols_to_plot = ['Journey Duration', 'Delay']
for col in numerical_cols_to_plot:
    plt.figure(figsize=(12, 6))
    sns.histplot(df_high_price[col], kde=True, color='skyblue', label='High Price')
    sns.histplot(df_not_high_price[col], kde=True, color='salmon', label='Not High Price')
    plt.title(f'Distribution of {col} by Price Category')
    plt.xlabel(col)
    plt.ylabel('Frequency')
    plt.legend()
    plt.show()

categorical_cols_to_encode = ['Purchase Type', 'Ticket Class', 'Ticket Type', 'Journey Status', 'Refund Request']
df_high_price_encoded = pd.get_dummies(df_high_price, columns=categorical_cols_to_encode, drop_first=False)
df_not_high_price_encoded = pd.get_dummies(df_not_high_price, columns=categorical_cols_to_encode, drop_first=False)

categorical_cols_to_plot = [col for col in df_high_price_encoded.columns if any(cat in col for cat in categorical_cols_to_encode)]
for col in categorical_cols_to_plot:
    if df_high_price_encoded[col].nunique() > 1: # Only plot if there are at least two categories
        plt.figure(figsize=(8, 5))
        high_price_counts = df_high_price_encoded[col].value_counts(normalize=True).reset_index()
        high_price_counts['Price Category'] = 'High Price'
        not_high_price_counts = df_not_high_price_encoded[col].value_counts(normalize=True).reset_index()
        not_high_price_counts['Price Category'] = 'Not High Price'
        combined_counts = pd.concat([high_price_counts, not_high_price_counts])
        sns.barplot(x=col, y='proportion', hue='Price Category', data=combined_counts)
        plt.title(f'Proportion of {col} by Price Category')
        plt.xlabel(col)
        plt.ylabel('Proportion')
        plt.show()

"""## Analyze relationship between price and other variables

### Subtask:
Explore the correlation or relationship between 'Price' and other numerical and categorical variables to understand which factors might influence the ticket price.

**Reasoning**:
Calculate and display the correlation matrix for the numerical columns and create a heatmap to visualize the relationships.
"""

numerical_cols = ['Price', 'Journey Duration', 'Delay', 'Price_winsorized']
correlation_matrix = df[numerical_cols].corr()
print("Correlation Matrix for Numerical Columns:")
display(correlation_matrix)

plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap of Numerical Columns')
plt.show()

"""**Reasoning**:
Create box plots to visualize the distribution of 'Price' for key categorical columns and calculate the average 'Price' for each category.


"""

categorical_cols_for_boxplot = ['Ticket Class', 'Ticket Type', 'Purchase Type', 'Journey Status', 'Payment Method']
for col in categorical_cols_for_boxplot:
    plt.figure(figsize=(10, 6))
    sns.boxplot(x=col, y='Price', data=df)
    plt.title(f'Price Distribution by {col}')
    plt.xlabel(col)
    plt.ylabel('Price')
    plt.show()

    print(f"\nAverage Price by {col}:")
    average_price_by_category = df.groupby(col, observed=True)['Price'].mean()
    display(average_price_by_category)

"""#**Analyze purchase trends over time**

Resample the DataFrame by day, week, and month to analyze purchase trends over different time periods and then plot the results.
"""

daily_purchases = df.set_index('Date of Purchase').resample('D').size().reset_index(name='purchase_count')
weekly_purchases = df.set_index('Date of Purchase').resample('W').size().reset_index(name='purchase_count')
monthly_purchases = df.set_index('Date of Purchase').resample('M').size().reset_index(name='purchase_count')

plt.figure(figsize=(12, 6))
sns.lineplot(x='Date of Purchase', y='purchase_count', data=daily_purchases)
plt.title('Daily Purchase Trends')
plt.xlabel('Date')
plt.ylabel('Number of Purchases')
plt.show()

plt.figure(figsize=(12, 6))
sns.lineplot(x='Date of Purchase', y='purchase_count', data=weekly_purchases)
plt.title('Weekly Purchase Trends')
plt.xlabel('Date')
plt.ylabel('Number of Purchases')
plt.show()

plt.figure(figsize=(12, 6))
sns.lineplot(x='Date of Purchase', y='purchase_count', data=monthly_purchases)
plt.title('Monthly Purchase Trends')
plt.xlabel('Date')
plt.ylabel('Number of Purchases')
plt.show()

"""#**Identify peak purchase periods**

**Reasoning**:
Find and print the peak daily, weekly, and monthly purchase periods and their corresponding purchase counts.
"""

peak_day = daily_purchases.loc[daily_purchases['purchase_count'].idxmax()]
peak_week = weekly_purchases.loc[weekly_purchases['purchase_count'].idxmax()]
peak_month = monthly_purchases.loc[monthly_purchases['purchase_count'].idxmax()]
print("Peak Daily Purchase Period:")
display(peak_day)
print("\nPeak Weekly Purchase Period:")
display(peak_week)
print("\nPeak Monthly Purchase Period:")
display(peak_month)

"""#**Explore seasonality**

Extract the month and day of the week from the 'Date of Purchase' column and store them in new columns named 'purchase_month' and 'purchase_day_of_week'. Then calculate the average number of purchases for each month and each day of the week. Finally, create bar plots to visualize the average number of purchases by month and day of the week.
"""

df['purchase_month'] = df['Date of Purchase'].dt.month
df['purchase_day_of_week'] = df['Date of Purchase'].dt.day_name()

average_purchases_by_month = df.groupby('purchase_month').size().reset_index(name='average_purchases')
average_purchases_by_month['average_purchases'] = average_purchases_by_month['average_purchases'] / len(df['Date of Purchase'].dt.to_period('M').unique())

average_purchases_by_day_of_week = df.groupby('purchase_day_of_week').size().reset_index(name='average_purchases')
days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
average_purchases_by_day_of_week['purchase_day_of_week'] = pd.Categorical(average_purchases_by_day_of_week['purchase_day_of_week'], categories=days_order, ordered=True)
average_purchases_by_day_of_week = average_purchases_by_day_of_week.sort_values('purchase_day_of_week')
average_purchases_by_day_of_week['average_purchases'] = average_purchases_by_day_of_week['average_purchases'] / len(df['Date of Purchase'].dt.to_period('W').unique())

plt.figure(figsize=(10, 6))
sns.barplot(x='purchase_month', y='average_purchases', data=average_purchases_by_month)
plt.title('Average Number of Purchases by Month')
plt.xlabel('Month')
plt.ylabel('Average Number of Purchases')
plt.xticks(ticks=range(12), labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
plt.show()

plt.figure(figsize=(10, 6))
sns.barplot(x='purchase_day_of_week', y='average_purchases', data=average_purchases_by_day_of_week)
plt.title('Average Number of Purchases by Day of the Week')
plt.xlabel('Day of the Week')
plt.ylabel('Average Number of Purchases')
plt.show()

"""#**Analyze purchase day of the week**

Calculate the number of purchases for each day of the week, sort the results, print the counts, and identify the day with the highest number of purchases.
"""

purchases_by_day_of_week = df['purchase_day_of_week'].value_counts()
print("Number of purchases for each day of the week:")
display(purchases_by_day_of_week)
most_popular_day = purchases_by_day_of_week.idxmax()
print(f"\nThe day of the week with the most purchases is: {most_popular_day}")

"""#**Analyze purchase time of day**

Extract the hour from 'Time of Purchase', count purchases per hour, print counts, and find the hour with the most purchases.
"""

df['purchase_hour'] = df['Time of Purchase'].dt.hour
purchases_by_hour = df['purchase_hour'].value_counts().sort_index()
print("Number of purchases for each hour of the day:")
display(purchases_by_hour)
most_popular_hour = purchases_by_hour.idxmax()
print(f"\nThe hour of the day with the most purchases is: {most_popular_hour}")

"""**Reasoning**:
Create a bar plot to visualize the number of purchases by hour, add title and labels, and display the plot.


"""

plt.figure(figsize=(12, 6))
sns.barplot(x=purchases_by_hour.index, y=purchases_by_hour.values)
plt.title('Number of Purchases by Hour of the Day')
plt.xlabel('Hour of the Day')
plt.ylabel('Number of Purchases')
plt.xticks(rotation=0)
plt.show()

"""#**Analyze purchase time of day**

Extract the hour from 'Time of Purchase', count purchases per hour, print counts, and find the hour with the most purchases.
"""

df['purchase_hour'] = df['Time of Purchase'].dt.hour
purchases_by_hour = df['purchase_hour'].value_counts().sort_index()
print("Number of purchases for each hour of the day:")
display(purchases_by_hour)
most_popular_hour = purchases_by_hour.idxmax()
print(f"\nThe hour of the day with the most purchases is: {most_popular_hour}")

"""#**Visualize purchase time distribution**

Create a bar plot to visualize the number of purchases by hour, add title and labels, and display the plot.
"""

plt.figure(figsize=(12, 6))
sns.barplot(x=purchases_by_hour.index, y=purchases_by_hour.values)
plt.title('Number of Purchases by Hour of the Day')
plt.xlabel('Hour of the Day')
plt.ylabel('Number of Purchases')
plt.xticks(rotation=0)
plt.show()

"""#**Analyze departure time distribution**

Extract the hour from 'Departure Time', count occurrences per hour, sort by hour, print counts, find the hour with the most occurrences, and print the peak hour.
"""

df['departure_hour'] = df['Departure Time'].dt.hour
departures_by_hour = df['departure_hour'].value_counts().sort_index()
print("Number of departures for each hour of the day:")
display(departures_by_hour)
most_popular_departure_hour = departures_by_hour.idxmax()
print(f"\nThe hour of the day with the most departures is: {most_popular_departure_hour}")

"""
Visualize the number of departures by hour using a bar plot to better understand the distribution and visually confirm the peak hours.

"""

plt.figure(figsize=(12, 6))
sns.barplot(x=departures_by_hour.index, y=departures_by_hour.values)
plt.title('Number of Departures by Hour of the Day')
plt.xlabel('Hour of the Day')
plt.ylabel('Number of Departures')
plt.xticks(rotation=0)
plt.show()

"""#**Analyze arrival time distribution**

Extract the hour from the 'Arrival Time' column, count the occurrences of each hour, sort the results, print the counts, and find the hour with the most arrivals.
"""

df['arrival_hour'] = df['Arrival Time'].dt.hour
arrivals_by_hour = df['arrival_hour'].value_counts().sort_index()
print("Number of arrivals for each hour of the day:")
display(arrivals_by_hour)
most_popular_arrival_hour = arrivals_by_hour.idxmax()
print(f"\nThe hour of the day with the most arrivals is: {most_popular_arrival_hour}")

"""
Create a bar plot to visualize the number of arrivals by hour, add title and labels, and display the plot.

"""

plt.figure(figsize=(12, 6))
sns.barplot(x=arrivals_by_hour.index, y=arrivals_by_hour.values)
plt.title('Number of Arrivals by Hour of the Day')
plt.xlabel('Hour of the Day')
plt.ylabel('Number of Arrivals')
plt.xticks(rotation=0)
plt.show()

"""#**Identify peak travel times**

Based on the outputs of the previous subtasks, identify and display the peak travel periods.
"""

print(f"Peak Departure Hour: {most_popular_departure_hour}")
print(f"Peak Arrival Hour: {most_popular_arrival_hour}")
print("\nBased on the analysis of departure and arrival times, the overall peak travel periods are in the early morning (around 7-9 AM), late afternoon (around 5 PM), and early evening (around 6-7 PM).")

"""#**Geographical Analysis: Identifying Busiest Stations**"""

# Calculate the number of departures from each station
departure_counts = df['Departure Station'].value_counts()

print("Number of departures from each station:")
display(departure_counts)

# Calculate the number of arrivals at each station
arrival_counts = df['Arrival Destination'].value_counts()

print("\nNumber of arrivals at each station:")
display(arrival_counts)

"""**Summary of Busiest Stations:**

Based on the departure and arrival counts, we can identify the stations with the highest traffic.
"""

print("\nTop 5 Busiest Departure Stations:")
display(departure_counts.head())

print("\nTop 5 Busiest Arrival Stations:")
display(arrival_counts.head())

"""## Visualize Important Routes"""

# Create a pivot table to show the number of journeys between departure and arrival stations
route_matrix = df.pivot_table(index='Departure Station', columns='Arrival Destination', values='Transaction ID', aggfunc='count', fill_value=0)

plt.figure(figsize=(14, 10))
sns.heatmap(route_matrix, annot=True, fmt='d', cmap='viridis')
plt.title('Network Heatmap of Journeys Between Stations')
plt.xlabel('Arrival Destination')
plt.ylabel('Departure Station')
plt.xticks(rotation=90)
plt.yticks(rotation=0)
plt.tight_layout()
plt.show()

"""#**Define routes**

Concatenate the 'Departure Station' and 'Arrival Destination' columns to create the 'Route' column and display the head of the dataframe to confirm the creation of the new column.
"""

df['Route'] = df['Departure Station'].astype(str) + ' to ' + df['Arrival Destination'].astype(str)
display(df.head())

"""
The error indicates that the 'Departure Station' and 'Arrival Destination' columns are of categorical type and cannot be directly concatenated with a string. Convert these columns to string type before concatenation.

"""

df['Route'] = df['Departure Station'].astype(str) + ' to ' + df['Arrival Destination'].astype(str)
display(df.head())

"""#**Identify popular routes**

Calculate and print the value counts for the 'Route' column to identify the most popular routes and find and print the route with the highest number of purchases.
"""

route_counts = df['Route'].value_counts()
print("Number of purchases for each route:")
display(route_counts)
most_popular_route = route_counts.idxmax()
print(f"\nThe most popular route is: {most_popular_route}")

"""#**Analyze popular routes**

Calculate the average price, journey duration, and delay for each route and print them sorted.
"""

average_price_by_route = df.groupby('Route')['Price'].mean()
average_journey_duration_by_route = df.groupby('Route')['Journey Duration'].mean()
average_delay_by_route = df.groupby('Route')['Delay'].mean()

print("Average Price by Route (Descending):")
display(average_price_by_route.sort_values(ascending=False))

print("\nAverage Journey Duration by Route (Descending):")
display(average_journey_duration_by_route.sort_values(ascending=False))

print("\nAverage Delay by Route (Descending):")
display(average_delay_by_route.sort_values(ascending=False))

"""
Synthesize the findings from the previous steps regarding popular routes and summarize the key insights about their characteristics.

"""

print("Summary of Key Insights about Popular Routes:")
print("-" * 50)
print(f"The most popular route by number of purchases is: {most_popular_route} with {route_counts.loc[most_popular_route]} purchases.")
print("\nCharacteristics of Popular Routes (Top 10 by Purchase Count):")
top_10_routes = route_counts.head(10).index
for route in top_10_routes:
    avg_price = average_price_by_route.get(route, 'N/A')
    avg_duration = average_journey_duration_by_route.get(route, 'N/A')
    avg_delay = average_delay_by_route.get(route, 'N/A')
    print(f"\nRoute: {route}")
    print(f"  Average Price: {avg_price:.2f}" if isinstance(avg_price, (int, float)) else f"  Average Price: {avg_price}")
    print(f"  Average Journey Duration (minutes): {avg_duration:.2f}" if isinstance(avg_duration, (int, float)) else f"  Average Journey Duration (minutes): {avg_duration}")
    print(f"  Average Delay (minutes): {avg_delay:.2f}" if isinstance(avg_delay, (int, float)) else f"  Average Delay (minutes): {avg_delay}")

print("\nComparison of Popular Routes:")
print("While Manchester Piccadilly to Liverpool Lime Street is the most popular route by volume, other routes may have different characteristics regarding price, duration, and delay.")
print("For example, routes to/from London stations often have higher average prices.")
print("Routes with longer distances tend to have longer journey durations and potentially higher average delays.")
print("The 'Journey Status' analysis showed that popular routes like Manchester Piccadilly to Liverpool Lime Street have a significant proportion of delayed journeys.")

print("\nOverall Takeaways:")
print("- Route popularity is not directly correlated with average price, journey duration, or delay.")
print("- High-volume routes can still experience significant delays.")
print("- Factors like distance, station location (e.g., London), and ticket class likely play a larger role in determining price and duration than just route popularity.")

"""#**Analyze journey status distribution**

Calculate and print the value counts and proportions of the 'Journey Status' column and create a bar plot to visualize the distribution.
"""

journey_status_counts = df['Journey Status'].value_counts()
print("Number of journeys for each status:")
display(journey_status_counts)
journey_status_proportions = df['Journey Status'].value_counts(normalize=True)
print("\nProportion of journeys for each status:")
display(journey_status_proportions)
plt.figure(figsize=(8, 5))
sns.barplot(x=journey_status_proportions.index, y=journey_status_proportions.values)
plt.title('Distribution of Journey Status')
plt.xlabel('Journey Status')
plt.ylabel('Proportion')
plt.show()

"""#**Investigate reasons for delay**

Calculate value counts and proportions for 'Reason for Delay' and visualize the proportions with a bar plot to understand the most common causes of delays.
"""

reason_cols = [col for col in df.columns if col.startswith('Reason for Delay_')]
reason_for_delay_counts = df[reason_cols].sum().sort_values(ascending=False)
print("Number of occurrences for each reason for delay:")
display(reason_for_delay_counts)

reason_for_delay_proportions = reason_for_delay_counts / len(df)
print("\nProportion of each reason for delay:")
display(reason_for_delay_proportions)

plt.figure(figsize=(10, 6))
sns.barplot(x=reason_for_delay_proportions.index, y=reason_for_delay_proportions.values)
plt.title('Proportion of Journeys by Reason for Delay')
plt.xlabel('Reason for Delay')
plt.ylabel('Proportion')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""
The 'Reason for Delay' column was one-hot encoded in a previous step and no longer exists. I need to use the one-hot encoded columns to analyze the reasons for delay. I will sum the one-hot encoded columns to get the counts for each reason, then calculate the proportions and plot them.

"""

reason_cols = [col for col in df.columns if col.startswith('Reason for Delay_')]
reason_for_delay_counts = df[reason_cols].sum().sort_values(ascending=False)
print("Number of occurrences for each reason for delay:")
display(reason_for_delay_counts)
reason_for_delay_proportions = reason_for_delay_counts / len(df)
print("\nProportion of each reason for delay:")
display(reason_for_delay_proportions)
plt.figure(figsize=(10, 6))
sns.barplot(x=reason_for_delay_proportions.index, y=reason_for_delay_proportions.values)
plt.title('Proportion of Journeys by Reason for Delay')
plt.xlabel('Reason for Delay')
plt.ylabel('Proportion')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""#**Analyze delay by route**

### Analyze delay reasons by station
"""

# Calculate the proportion of each delay reason for each departure station
delay_reason_by_departure_station = df.groupby('Departure Station')[reason_cols].mean()
print("Proportion of each delay reason by Departure Station:")
display(delay_reason_by_departure_station)

# Calculate the proportion of each delay reason for each arrival station
delay_reason_by_arrival_station = df.groupby('Arrival Destination')[reason_cols].mean()
print("\nProportion of each delay reason by Arrival Station:")
display(delay_reason_by_arrival_station)

# Visualize the proportion of each delay reason by Departure Station for the top N stations
N = 10 # You can adjust this number
top_departure_stations = departure_counts.head(N).index
delay_reason_by_departure_station_top_N = delay_reason_by_departure_station.loc[top_departure_stations]
delay_reason_by_departure_station_top_N = delay_reason_by_departure_station_top_N.transpose()

plt.figure(figsize=(14, 8))
delay_reason_by_departure_station_top_N.plot(kind='bar', stacked=True, figsize=(14,8))
plt.title('Proportion of Delay Reasons by Top 10 Departure Stations')
plt.xlabel('Reason for Delay')
plt.ylabel('Proportion')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Departure Station', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# Visualize the proportion of each delay reason by Arrival Station for the top N stations
top_arrival_stations = arrival_counts.head(N).index
delay_reason_by_arrival_station_top_N = delay_reason_by_arrival_station.loc[top_arrival_stations]
delay_reason_by_arrival_station_top_N = delay_reason_by_arrival_station_top_N.transpose()

plt.figure(figsize=(14, 8))
delay_reason_by_arrival_station_top_N.plot(kind='bar', stacked=True, figsize=(14,8))
plt.title('Proportion of Delay Reasons by Top 10 Arrival Stations')
plt.xlabel('Reason for Delay')
plt.ylabel('Proportion')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Arrival Station', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""
Calculate the proportion of delayed journeys for each route, sort the results, and print the top N routes with the highest proportion of delays.

"""

delayed_journeys = df[df['Journey Status'] == 'Delayed']
delayed_proportion_by_route = delayed_journeys.groupby('Route').size() / df.groupby('Route').size()
delayed_proportion_by_route = delayed_proportion_by_route.sort_values(ascending=False)
N = 15
print(f"Top {N} Routes with Highest Proportion of Delayed Journeys:")
display(delayed_proportion_by_route.head(N))

"""
Create a bar plot to visualize the proportion of delayed journeys for the top N routes.

"""

plt.figure(figsize=(12, 8))
sns.barplot(x=delayed_proportion_by_route.head(N).index, y=delayed_proportion_by_route.head(N).values)
plt.title(f'Top {N} Routes by Proportion of Delayed Journeys')
plt.xlabel('Route')
plt.ylabel('Proportion of Delayed Journeys')
plt.xticks(rotation=90, ha='right')
plt.tight_layout()
plt.show()

"""#**Analyze delay by time of day**

Extract the hour from 'Departure Time', filter for delayed journeys, calculate the proportion of delayed journeys per hour, and visualize the results.
"""

df['departure_hour'] = df['Departure Time'].dt.hour
delayed_journeys = df[df['Journey Status'] == 'Delayed'].copy()
delayed_by_hour = delayed_journeys['departure_hour'].value_counts().sort_index()
total_journeys_by_hour = df['departure_hour'].value_counts().sort_index()
proportion_delayed_by_hour = delayed_by_hour / total_journeys_by_hour

print("Proportion of Delayed Journeys by Departure Hour:")
display(proportion_delayed_by_hour.sort_values(ascending=False))

plt.figure(figsize=(12, 6))
sns.barplot(x=proportion_delayed_by_hour.index, y=proportion_delayed_by_hour.values)
plt.title('Proportion of Delayed Journeys by Departure Hour')
plt.xlabel('Departure Hour of the Day')
plt.ylabel('Proportion of Delayed Journeys')
plt.xticks(rotation=0)
plt.show()

"""#**Analyze delay by other factors**

Create box plots to visualize the distribution of 'Delay' for 'Ticket Class', 'Ticket Type', and 'Railcard' columns and calculate and print the average 'Delay' for each category within these columns.
"""

categorical_cols_for_delay_analysis = ['Ticket Class', 'Ticket Type', 'Railcard']
for col in categorical_cols_for_delay_analysis:
    plt.figure(figsize=(10, 6))
    sns.boxplot(x=col, y='Delay', data=df)
    plt.title(f'Delay Distribution by {col}')
    plt.xlabel(col)
    plt.ylabel('Delay (minutes)')
    plt.show()
    print(f"\nAverage Delay by {col}:")
    average_delay_by_category = df.groupby(col)['Delay'].mean()
    display(average_delay_by_category)

"""#**Quantify impact of factors on delay**

Create dummy variables for categorical columns, define features and target, split data, train a linear regression model, and print the coefficients to quantify the impact of features on delay.
"""

categorical_cols_for_dummies = ['Ticket Class', 'Ticket Type', 'Railcard']
df_encoded = pd.get_dummies(df, columns=categorical_cols_for_dummies, drop_first=True)
numerical_cols = ['Price', 'Journey Duration']
feature_cols = numerical_cols + [col for col in df_encoded.columns if col.startswith(('Ticket Class_', 'Ticket Type_', 'Railcard_'))]
X = df_encoded[feature_cols]
y = df_encoded['Delay']
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
from sklearn.linear_model import LinearRegression
model = LinearRegression()
model.fit(X_train, y_train)
print("Linear Regression Model Coefficients:")
display(pd.DataFrame({'Feature': X.columns, 'Coefficient': model.coef_}))
from sklearn.metrics import mean_squared_error, r2_score
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f"\nMean Squared Error (MSE) on Test Set: {mse:.2f}")
print(f"R-squared (R2) on Test Set: {r2:.2f}")

"""#**Identify relevant features for segmentation**

#**Data preparation for segmentation**

Select relevant features, perform one-hot encoding on categorical features, and standardize numerical features.
"""

from sklearn.preprocessing import StandardScaler

relevant_features = ['Purchase Type', 'Ticket Class', 'Ticket Type', 'Railcard', 'Price', 'Route', 'Delay']
df_segmentation = df[relevant_features].copy()

categorical_cols = ['Purchase Type', 'Ticket Class', 'Ticket Type', 'Railcard', 'Route']
df_segmentation_encoded = pd.get_dummies(df_segmentation, columns=categorical_cols, drop_first=True)

numerical_cols = ['Price', 'Delay']
scaler = StandardScaler()
df_segmentation_encoded[numerical_cols] = scaler.fit_transform(df_segmentation_encoded[numerical_cols])

display(df_segmentation_encoded.head())

"""#**Apply segmentation technique**

Apply K-Means clustering to the prepared data and add the cluster labels to the original segmentation dataframe.
"""

from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=5, random_state=42, n_init=10)
kmeans.fit(df_segmentation_encoded)
df_segmentation['Segment'] = kmeans.labels_

display(df_segmentation.head())
print("\nNumber of data points in each segment:")
print(df_segmentation['Segment'].value_counts())

"""#**Analyze customer segments**

Group the DataFrame by 'Segment' and calculate the mean for numerical columns and value counts/proportions for categorical columns to analyze segment characteristics.
"""

numerical_cols = ['Price', 'Delay']
categorical_cols = ['Purchase Type', 'Ticket Class', 'Ticket Type', 'Railcard', 'Route']
segment_characteristics = {}
for segment in df_segmentation['Segment'].unique():
    segment_data = df_segmentation[df_segmentation['Segment'] == segment]
    segment_characteristics[segment] = {
        'Numerical_Summary': segment_data[numerical_cols].mean(),
        'Categorical_Summary': {}
    }
    for col in categorical_cols:
        segment_characteristics[segment]['Categorical_Summary'][col] = {
            'Counts': segment_data[col].value_counts(),
            'Proportions': segment_data[col].value_counts(normalize=True)
        }
for segment, characteristics in segment_characteristics.items():
    print(f"Segment {segment} Characteristics:")
    print("Numerical Summary:")
    display(characteristics['Numerical_Summary'])
    print("\nCategorical Summary:")
    for col, summary in characteristics['Categorical_Summary'].items():
        print(f"\n{col}:")
        print("Counts:")
        display(summary['Counts'])
        print("Proportions:")
        display(summary['Proportions'])
    print("-" * 50)

"""#**Visualize customer segments**

Create box plots to visualize the distribution of 'Price' and 'Delay' for each segment, and bar plots to visualize the proportion of 'Purchase Type', 'Ticket Class', 'Ticket Type', and 'Railcard' for each segment.
"""

numerical_cols = ['Price', 'Delay']
for col in numerical_cols:
    plt.figure(figsize=(10, 6))
    sns.boxplot(x='Segment', y=col, data=df_segmentation)
    plt.title(f'Distribution of {col} by Segment')
    plt.xlabel('Segment')
    plt.ylabel(col)
    plt.show()
categorical_cols = ['Purchase Type', 'Ticket Class', 'Ticket Type', 'Railcard']
for col in categorical_cols:
    plt.figure(figsize=(10, 6))
    sns.countplot(x='Segment', hue=col, data=df_segmentation, palette='viridis')
    plt.title(f'Distribution of {col} by Segment')
    plt.xlabel('Segment')
    plt.ylabel('Count')
    plt.legend(title=col)
    plt.show()

"""
Create bar plots to visualize the proportion of the top N 'Route' for each segment.

"""

N = 10
for segment in df_segmentation['Segment'].unique():
    segment_data = df_segmentation[df_segmentation['Segment'] == segment]
    route_proportions = segment_data['Route'].value_counts(normalize=True).head(N)
    plt.figure(figsize=(12, 6))
    sns.barplot(x=route_proportions.index, y=route_proportions.values, palette='viridis')
    plt.title(f'Top {N} Routes Proportion for Segment {segment}')
    plt.xlabel('Route')
    plt.ylabel('Proportion')
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    plt.show()